;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DAT_IMAGEMEMXFER
;   This test scans one sheet of paper for the default pixeltype.  An ADF
;   is required to pass this test, but that was already been tested before
;   we got to this function.
;
;   Here's the basic flow:
;       SetCapabilities
;       start scanning
;       while images
;           transfer image
;           DAT_EXTIMAGEINFO
;           end image
;       end
;       end scanning
;       verify the results
;
;   The test passes if:
;       - all of the capabilities can be set
;       - TWEI_PRINTER matches CAP_PRINTER
;       - TWEI_PRINTERSTRING starts with 'TWAIN' and ends with 'TEST'
;
; Arguments
;   arg:1 - TW_IDENTITY.ProductName of scanner to test
;   arg:2 - global for us to update on failure
;   arg:3 - value of ShowUI (TRUE or FALSE)
;   arg:4 - test name for the image folder
;   arg:5 - expected value for TWEI_PRINTER
;
; Locals
;   name - current test being done
;   indent - indent the passfail text
;   imageinfo - metadata for the current image
;   imagememxfer - result of DAT_IMAGEMEMXFER call
;   setupmemxfer.preferred - preferred field from DAT_SETUPMEMXFER call
;
;   image.count - count of images from 1
;   image.folder - folder to put the images in
;
;   feederenabled.list - scanner's feederenabled values
;   feederenabled.index - index of feederenabled values
;   feederenabled.value - current feederenabled value
;
;   pixeltype.list - scanner's pixeltype values for this feederenabled
;   pixeltype.index - index of pixeltype values
;   pixeltype.value - current pixeltype value
;
; Returns
;   pass or fail
;



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initialize...
;
echo.titletest 'DAT_IMAGEMEMXFER v1.0 28-Jun-2021'
;
setlocal indent ''
setlocal image.pointer '0'
setlocal image.count '0'
setlocal image.folder '${folder:certimages}/${arg:4}/DAT_IMAGEMEMXFER'
setlocal showui '${arg:3}'
;
setglobal g_barcodemaxsearchpriorities.max '0'
setglobal g_barcodecount.none '0'
setglobal g_barcodecount.one '0'
setglobal g_barcodecount.many '0'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Clean the image folder for this test...
;
image cleanfolderandmeta '${get:image.folder}'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SetCapabilities
; This resets the driver and sets all the capabilities we need for the test.
; If its return code is not 'pass', end with an error
;
run SetCapabilities 'TWSX_MEMORY' '${get:indent}'
if '${ret:}' != 'pass' goto MAIN.ERROR.FAIL



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get the preferred size for memory transfers, and allocate
; a pointer for the memory transfers...
;
setlocal indent '    '
setlocal name 'dg_control/dat_setupmemxfer/msg_get'
dsmentry src ds dg_control dat_setupmemxfer msg_get '0,0,0'
if '${sts:}' != 'SUCCESS' goto MAIN.ERROR.ECHOPASSFAIL
echo.passfail '${get:indent}${get:name}' 'pass'
;
setlocal name 'TW_SETUPMEMXFER.Preferred > 0'
setlocal setupmemxfer.preferred '${ret:${get:TW_SETUPMEMXFER.Preferred}}'
if '${get:setupmemxfer.preferred}' <= '0' goto MAIN.ERROR.ECHOPASSFAIL
echo.passfail '${get:indent}${get:name}' 'pass'
;
setlocal name 'allocate pointer for ${get:setupmemxfer.preferred} bytes'
free pointer image.pointer ; for the last loop
allocate pointer image.pointer '${get:setupmemxfer.preferred}'
if '${get:image.pointer}' == '0' goto MAIN.ERROR.ECHOPASSFAIL
echo.passfail '${get:indent}${get:name}' 'pass'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Prompt the user...
;
echo.prompt
echo.prompt "Scanning will take place during this test.  There will be no"
echo.prompt "need to press any button on the TWAIN user interface to start"
echo.prompt "the scanner.  A progress indicator may appear during scanning."
echo.prompt
echo.prompt "Place 1 sheet in the scanner's feeder.  The scanner will print"
echo.prompt "text on this sheet."
echo.prompt
pause '(press the ENTER key when ready to continue)'
echo.prompt



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Start scanning...
;
:MAIN.USERINTERFACE
setlocal name 'dg_control/dat_userinterface/msg_enableds'
wait reset
dsmentry src null dg_control dat_userinterface msg_enableds '${get:showui},0'
if '${sts:}' != 'SUCCESS' goto MAIN.ERROR.ECHOPASSFAIL
echo.passfail '${get:indent}${get:name}' 'pass'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Wait for MSG_XFERREADY, if we don't see it then scoot...
;
setlocal name 'wait ${get:sys_waittimeout} seconds for MSG_XFERREADY'
wait '${get:sys_waittimeout}000'
if '${ret:}' !~contains 'msg_xferready' goto MAIN.ERROR.ECHOPASSFAIL
echo.passfail '${get:indent}${get:name}' 'pass'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Do a memory transfer...
; This little song and dance with the states is so that we can
; start the transfer in state 6 with each new image, but switch
; to state 7 if we need multiple calls to capture the current
; image...
;
; The saved images will be in TIFF format, which includes TIFF
; JPEG (the better form, where a simple TIFF header is added).
;
increment image.count '${get:image.count}' 1
image free memimage
;
:MAIN.IMAGEMEMXFER.NEXT
setlocal name 'dg_image/dat_imagememxfer/msg_get'
dsmentry src ds dg_image dat_imagememxfer msg_get '0,0,0,0,0,0,0,9,${get:setupmemxfer.preferred},${get:image.pointer}'
setlocal imagememxfer '${ret:}'
if '${sts:}' == 'XFERDONE' goto MAIN.IMAGEMEMXFER.XFERDONE
if '${sts:}' != 'SUCCESS' goto MAIN.ERROR.ECHOPASSFAIL
;
echo.passfail '${get:indent}${get:name} SUCCESS' 'pass'
image append memimage '${get:imagememxfer}'
goto MAIN.IMAGEMEMXFER.NEXT
;
:MAIN.IMAGEMEMXFER.XFERDONE
echo.passfail '${get:indent}${get:name} XFERDONE' 'pass'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; We need image info to make sense of this data...
;
setlocal name 'dg_image/dat_imageinfo/msg_get'
dsmentry src ds dg_image dat_imageinfo msg_get '0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0'
setlocal imageinfo '${ret:}'
if '${sts:}' != 'SUCCESS' goto MAIN.ERROR.ECHOPASSFAIL
echo.passfail '${get:indent}${get:name}' 'pass'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Save the image...
;
image append memimage '${get:imagememxfer}'
image addheader memimage '${get:imageinfo}'
image save memimage memory '${get:image.folder}/adf${format:D6|${get:image.count}}'
echo.passfail '${get:indent}image <${ret:}>' 'pass'
image free memimage



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DAT_EXTIMAGEINFO
; Check the barcode metadata...
;
run DAT_EXTIMAGEINFO '${get:indent}' '${get:image.folder}/adf${format:D6|${get:image.count}}'
if '${ret:}' != 'pass' goto MAIN.ERROR.FAIL



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; End the transfer, see if we're done...
;
setlocal name 'dg_control/dat_pendingxfers/msg_endxfer'
dsmentry src ds dg_control dat_pendingxfers msg_endxfer '0,0'
if '${sts:}' != 'SUCCESS' goto MAIN.ERROR.ECHOPASSFAIL
echo.passfail '${get:indent}${get:name}' 'pass'
increment image.count '${get:image.count}' 1
if '${ret:${get:TW_PENDINGXFERS.Count}}' != '0' goto MAIN.IMAGEMEMXFER.NEXT



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; We're out of images, so disable...
;
setlocal name 'dg_control/dat_userinterface/msg_disableds'
dsmentry src ds dg_control dat_userinterface msg_disableds '0,0'
if '${sts:}' != 'SUCCESS' goto MAIN.ERROR.ECHOPASSFAIL
echo.passfail '${get:indent}${get:name}' 'pass'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Check to see if we passed.  We need one sheet of paper with no barcodes.  Two or more sheets
; with one barcode, and no sheets with multiple barecodes if the maximum value of
; ICAP_BARCODEMAXSEARCHPRIORITIES is 1.  And one or more sheets with one barcode, and one or
; more sheets with multiple barcodes of ICAP_BARCODEMAXSEARCHPRIORITIES is greater than 1.
;
setlocal name 'Final Check: detected a sheet with 0 barcodes
if '${get:g_barcodecount.none}' < '1' goto MAIN.ERROR.ECHOPASSFAIL
echo.passfail '${get:indent}${get:name}' 'pass'
;
if '${get:g_barcodemaxsearchpriorities.max}' >= '2' goto MAIN.FINALCHECK.MANYBARCODES
setlocal name 'Final Check: detected multiple sheets with 1 barcode'
if '${get:g_barcodecount.one}' < '1' goto MAIN.ERROR.ECHOPASSFAIL
echo.passfail '${get:indent}${get:name}' 'pass'
setlocal name 'Final Check: detected 0 sheets with many barcodes (not supported)'
if '${get:g_barcodecount.many}' > '0' goto MAIN.ERROR.ECHOPASSFAIL
echo.passfail '${get:indent}${get:name}' 'pass'
goto MAIN.FINALCHECK.DONE
;
:MAIN.FINALCHECK.MANYBARCODES
setlocal name 'Final Check: detected a sheet with 1 barcode'
if '${get:g_barcodecount.one}' < '1' goto MAIN.ERROR.ECHOPASSFAIL
echo.passfail '${get:indent}${get:name}' 'pass'
setlocal name 'Final Check: detected a sheet with many barcodes'
if '${get:g_barcodecount.many}' < '1' goto MAIN.ERROR.ECHOPASSFAIL
echo.passfail '${get:indent}${get:name}' 'pass'
:MAIN.FINALCHECK.DONE



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Summary and cleanup...
;
; Did we pass? (do an extra check)
:MAIN.PASS
image free memimage
free pointer image.pointer
echo.passfail 'SUMMARY' 'pass'
return 'pass'
;
; Ruh-roh...
:MAIN.ERROR.ECHOPASSFAIL
image free memimage
free pointer image.pointer
echo.passfail '${get:indent}${get:name}' 'fail - ${sts:} ${ret:}'
echo.passfail 'SUMMARY' 'fail'
return 'fail'
;
; Ruh-roh...
:MAIN.ERROR.FAIL
image free memimage
free pointer image.pointer
echo.passfail 'SUMMARY' 'fail'
return 'fail'
